#version 450 core
#extension GL_ARB_separate_shader_objects : enable

#define SCENE_SHAPES_COUNT				    @SCENE_SHAPES_COUNT@
#define SCENE_SPHERE_SHAPES_COUNT		    @SCENE_SPHERE_SHAPES_COUNT@
#define SCENE_DIELECTRIC_MATERIALS_COUNT    @SCENE_DIELECTRIC_MATERIALS_COUNT@
#define SCENE_DIFFUSE_LIGHT_MATERIALS_COUNT @SCENE_DIFFUSE_LIGHT_MATERIALS_COUNT@
#define SCENE_LAMBERTIAN_MATERIALS_COUNT    @SCENE_LAMBERTIAN_MATERIALS_COUNT@
#define SCENE_METAL_MATERIALS_COUNT		    @SCENE_METAL_MATERIALS_COUNT@
#define SCENE_CHECKER_TEXTURES_COUNT	    @SCENE_CHECKER_TEXTURES_COUNT@
#define SCENE_CONSTANT_TEXTURES_COUNT	    @SCENE_CONSTANT_TEXTURES_COUNT@
#define SCENE_IMAGE_TEXTURES_COUNT		    @SCENE_IMAGE_TEXTURES_COUNT@
#define SCENE_NOISE_TEXTURES_COUNT		    @SCENE_NOISE_TEXTURES_COUNT@

// TYPE DEFINITIONS

// Indices

#define ArrayIndex uint

// Math constants

const float pi = 3.14159265358979323846264338327950288;
const float halfPi = 1.57079632679489661923132169163975144;
const float oneOverPi = 0.318309886183790671537767526745028724;
const float oneOverTwoPi = 0.159154943091895335768883763372514362;

// Sizes

struct FloatExtent2D
{
	float width;
	float height;
};

struct UintExtent2D
{
	uint width;
	uint height;
};

// Pairs

struct MinMax
{
	float lo;
	float hi;
};

struct UV
{
	float u;
	float v;
};

// Vector types

#define Position vec3		// Represents arbitrary point in space.
#define Displacement vec3	// Represents a transmission from one point to another.
#define Direction vec3		// Represents a direction, must be a unit vector.

const Direction X_AXIS = Direction(1, 0, 0);
const Direction Y_AXIS = Direction(0, 1, 0);
const Direction Z_AXIS = Direction(0, 0, 1);

// Random

float randomUniform();
float randomUniform(in const float lo, in const float hi);
Direction randomDirection();
Direction randomInUnitDisk(in const Direction axis);
Direction randomInUnitDisk();

// Geometric types

struct Line
{
	Position origin;
	Direction direction;
};

Position pointOnLine(in const Line line, in const float t);

struct Sphere
{
	Position origin;
	float radius;
};

UV uvOnSphere(in const Position normalizedP);

// Colors

#define Color vec3		// Normalized color.
#define ColorAlpha vec4	// Normalized color with an alpha channel.
#define RGBA uvec4		// RGBA color representation with integer values between 0 and 255.

RGBA toRGBA8(in const Color color);

// Textures

#define TextureTypeID uint

const TextureTypeID TEXTURE_TYPE_CHECKER  = 1;
const TextureTypeID TEXTURE_TYPE_CONSTANT = 2;
const TextureTypeID TEXTURE_TYPE_IMAGE    = 3;
const TextureTypeID TEXTURE_TYPE_NOISE    = 4;

struct Texture
{
	TextureTypeID type;
	ArrayIndex index;
};

struct CheckerTexture
{
	float scale;
	Texture odd;
	Texture even;
};

struct ConstantTexture
{
	Color value;
};

struct ImageTexture
{
	ArrayIndex imageIndex;
	UintExtent2D size;
};

struct NoiseTexture
{
	float scale;
	Color baseColor;
};

Color colorAtTexture(in const Texture tex, in const UV uv, in const Position position);
Color colorAtTexture(in const ConstantTexture tex, in const UV uv, in const Position position);
Color colorAtTexture(in const CheckerTexture tex, in const UV uv, in const Position position);
Color colorAtTexture(in const ImageTexture tex, in const UV uv, in const Position position);
Color colorAtTexture(in const NoiseTexture tex, in const UV uv, in const Position position);

// Materials

#define MaterialTypeID uint

const MaterialTypeID MATERIAL_TYPE_DIELECTRIC    = 1;
const MaterialTypeID MATERIAL_TYPE_DIFFUSE_LIGHT = 2;
const MaterialTypeID MATERIAL_TYPE_LAMBERTIAN    = 3;
const MaterialTypeID MATERIAL_TYPE_METAL	     = 4;

struct Material
{
	MaterialTypeID type;
	ArrayIndex index;
};

struct DielectricMaterial
{
	float refractiveIndex;
	Texture albedo;
};

struct DiffuseLightMaterial
{
	Texture emit;
};

struct LambertianMaterial
{
	Texture albedo;
};

struct MetalMaterial
{
	float fuzz;
	Texture albedo;
};

// Shapes

#define ShapeTypeID uint

const ShapeTypeID SHAPE_TYPE_SPHERE = 1;

struct Shape
{
	ShapeTypeID type;
	ArrayIndex index;
	Material material;
};

struct SphereShape
{
	Sphere shapeData;
};

// Ray

struct Ray
{
	Line line;
};

Color seenColor(in const Ray ray);

// Camera

struct Camera
{
	Position origin;
	Position lowerLeftCorner;
	Position horizontal;
	Position vertical;
	Displacement w;
	Displacement u;
	Displacement v;
	float lensRadius;
	MinMax time;
};

Ray shootRayAt(in const UV);

// Hit detection

struct Hit
{
	float t;
	Position point;
	Displacement normal;
	Material material;
	UV uv;
};

struct HitRecord
{
	bool occurred;
	Hit record;
};

HitRecord rayHits(in const Ray ray, in const SphereShape sphere, in const MinMax t);

// I/O

layout(push_constant) uniform RenderInfo
{
	UintExtent2D imageExtent;
	uint sampleCount;
	Camera camera;
} renderInfo;

layout(binding = 0) readonly uniform Scene
{
	Texture sky;

	Shape shapes[SCENE_SHAPES_COUNT];
	SphereShape sphereShapes[SCENE_SPHERE_SHAPES_COUNT];

	DielectricMaterial dielectricMaterials[SCENE_DIELECTRIC_MATERIALS_COUNT];
	DiffuseLightMaterial diffuseLightMaterials[SCENE_DIFFUSE_LIGHT_MATERIALS_COUNT];
	LambertianMaterial lambertianMaterials[SCENE_LAMBERTIAN_MATERIALS_COUNT];
	MetalMaterial metalMaterials[SCENE_METAL_MATERIALS_COUNT];

	CheckerTexture checkerTextures[SCENE_CHECKER_TEXTURES_COUNT];
	ConstantTexture constantTextures[SCENE_CONSTANT_TEXTURES_COUNT];
	ImageTexture imageTextures[SCENE_IMAGE_TEXTURES_COUNT];
	NoiseTexture noiseTextures[SCENE_NOISE_TEXTURES_COUNT];
} scene;

layout(binding = 1) uniform sampler2D textures[];

layout(binding = 2, rgba8ui) uniform writeonly uimage2D outImage;

// IMPLEMENTATIONS

void main()
{
	const float inverseImageWidth = 1.f / float(renderInfo.imageExtent.width);
	const float inverseImageHeight = 1.f / float(renderInfo.imageExtent.height);

	vec3 color;
	for (uint i = 0; i < renderInfo.sampleCount; ++i)
	{
		const UV uv = {
			float(gl_GlobalInvocationID.x + randomUniform()) * inverseImageWidth,
			float(renderInfo.imageExtent.height - gl_GlobalInvocationID.y + randomUniform()) * inverseImageHeight,
		};
		const Ray ray = shootRayAt(uv);
		color += seenColor(ray);
	}
	color /= float(renderInfo.sampleCount);

	imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), toRGBA8(color));
}

// Ray

Ray shootRayAt(in const UV uv)
{
	const Camera camera = renderInfo.camera;
	const Displacement randomSpotOnLens = camera.lensRadius * randomInUnitDisk();
	const Displacement offset = (camera.u * randomSpotOnLens.x) + (camera.v * randomSpotOnLens.y);
	const Position origin = camera.origin + offset;
	return Ray(Line(origin, camera.lowerLeftCorner + (uv.v * camera.horizontal) + (uv.u * camera.vertical) - origin));
}

Color seenColor(in const Ray ray)
{
	const float t = (0.5f * normalize(ray.line.direction).y) + 0.5f;
	return mix(Color(1.f), Color(0.5f, 0.7f, 1.f), t);
}

// Shapes

HitRecord rayHits(in const Ray ray, in const SphereShape sphere, in const MinMax t)
{
	const Sphere shapeData = sphere.shapeData;
	const Displacement oc = ray.line.origin - shapeData.origin;
	const float a = dot(ray.line.direction, ray.line.direction);
	const float b = dot(oc, ray.line.direction);
	const float c = dot(oc, oc) * pow(shapeData.radius, 2);
	const float discriminant = b * b - a * c;

	if (discriminant > 0)
	{
		float root = (-b - sqrt(discriminant)) / a;
		if (root > t.hi || root < t.lo)
		{
			root = (-b + sqrt(discriminant)) / a;
		}
		if (root < t.hi && root > t.lo)
		{
			const Position point = pointOnLine(ray.line, root);
			const UV uv = uvOnSphere(abs(1 / shapeData.radius) * (point - shapeData.origin));
			const Direction normal = (point - shapeData.origin) / shapeData.radius;
			return HitRecord(true, Hit(root, point, normal, Material(0, 0), uv));
		}
	}
	return HitRecord(false, Hit(0, Position(0), Displacement(0), Material(0, 0), UV(0, 0)));
}

// Textures

Color colorAtTexture(in const Texture tex, in const UV uv, in const Position position)
{
//	switch (tex.type)
//	{
//	case TEXTURE_TYPE_CHECKER:
//		return colorAtTexture(scene.checkerTextures[tex.index], uv, position);
//	case TEXTURE_TYPE_CONSTANT:
//		return colorAtTexture(scene.constantTextures[tex.index], uv, position);
//	case TEXTURE_TYPE_IMAGE:
//		return colorAtTexture(scene.imageTextures[tex.index], uv, position);
//	case TEXTURE_TYPE_NOISE:
//		return colorAtTexture(scene.noiseTextures[tex.index], uv, position);
//	}
	return Color(1.f);
}

Color colorAtTexture(in const ConstantTexture tex, in const UV uv, in const Position position)
{
	return tex.value;
}

Color colorAtTexture(in const ImageTexture tex, in const UV uv, in const Position position)
{
	return Color(1.f);
}

Color colorAtTexture(in const NoiseTexture tex, in const UV uv, in const Position position)
{
	return Color(1.f);
}

Color colorAtTexture(in const CheckerTexture tex, in const UV uv, in const Position position)
{
	if (sin(tex.scale * position.x) * sin(tex.scale * position.y) * sin(tex.scale * position.z) < 0)
	{
		return colorAtTexture(tex.odd, uv, position);
	}
	return colorAtTexture(tex.even, uv, position);
}

// Colors

RGBA toRGBA8(in const Color color)
{
	return uvec4(color * 255, 255);
}

// Geometric

Position pointOnLine(in const Line line, in const float t)
{
	return line.origin + (t * line.direction);
}

UV uvOnSphere(in const Position normalizedP)
{
	return UV(
        1 - (atan(normalizedP.z, normalizedP.x) + pi) * oneOverTwoPi,
        (asin(normalizedP.y) + halfPi) * oneOverPi);
}

// Random

float seed = 0;

float randomUniform()
{
	return fract(sin(seed += 0.01) * 100000.0);
}

float randomUniform(in const float lo, in const float hi)
{
	return lo + (randomUniform() * (hi - lo));
}

Direction randomDirection()
{
	while (true)
	{
		const Displacement direction = Displacement(
			randomUniform(-1.f, 1.f), randomUniform(-1.f, 1.f), randomUniform(-1.f, 1.f));
		const float l = length(direction);
		if (l * l < 1.f)
		{
			return direction;
		}
	}
}

Direction randomInUnitDisk(in const Direction axis)
{
	while (true)
	{
		const Displacement direction = (Direction(1.f) - axis) * randomDirection();
		if (dot(direction, direction) < 1.f)
		{
			return direction;
		}
	}
}

Direction randomInUnitDisk()
{
	return randomInUnitDisk(Z_AXIS);
}